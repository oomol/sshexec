package handler

import (
	"context"
	"github.com/gliderlabs/ssh"
	"github.com/sirupsen/logrus"
	"path/filepath"
	"sshd/pkg/define"
	"sshd/pkg/handler/internal/ffmpeg"
	"sshd/pkg/sio"
	"sshd/pkg/utils"
)

type Middleware func(next ssh.Handler) ssh.Handler

// WithMiddleware composes the provided Middleware and returns an ssh.Option.
// This is useful if you manually create an ssh.Server and want to set the
// Server.Handler.
//
// Notice that middlewares are composed from first to last, which means the last one is executed first.
func WithMiddleware(mw ...Middleware) ssh.Option {
	return func(s *ssh.Server) error {
		h := func(ssh.Session) {}
		for _, m := range mw {
			h = m(h)
		}
		s.Handler = h
		return nil
	}
}

func InstallFFMPEG(next ssh.Handler) ssh.Handler {
	return func(s ssh.Session) {
		if s.Command()[0] == define.InstallFFMPEG {
			ctx, cancel := context.WithCancel(context.Background())
			defer cancel()

			go func() {
				// The context is canceled when the client's connection closes or I/ O operation fails.
				<-s.Context().Done()
				cancel()
			}()

			// If given command is define.InstallFFMPEG, try to install ffmpeg

			sio.Println(s, "Try to install ffmpeg")

			stduioHome, err := utils.GetStudioHomeDir()
			if err != nil {
				sio.Fatalf(s, "GetStudioHomeDir error: %s \n", err.Error())
			}

			sio.Printf(s, "GetStudioHomeDir: %q \n", stduioHome)
			installer := ffmpeg.Installer{
				PREFIX:  filepath.Join(stduioHome, "host-shared"),
				URL:     define.FFReleaseURL,
				Session: s,
			}

			if err = installer.Download(ctx); err != nil {
				sio.Fatalf(s, "Download ffmpeg error: %s\n", err.Error())
			}

			if err = installer.Unpack(ctx); err != nil {
				sio.Fatalf(s, "Unpack ffmpeg error: %s\n", err.Error())
			}

			if err = installer.Setup(ctx); err != nil {
				sio.Fatalf(s, "Setup ffmpeg error: %s\n", err.Error())
			}
			if err = installer.Test(ctx); err != nil {
				sio.Fatalf(s, "Test ffmpeg error: %s\n", err.Error())
			}
			if err = installer.CleanUp(ctx); err != nil {
				sio.Fatalf(s, "Test ffmpeg error: %s\n", err.Error())
			}
		} else {
			next(s)
		}
	}
}

func RunFFMPEG(next ssh.Handler) ssh.Handler {
	return func(s ssh.Session) {
		if s.Command()[0] == define.FFMPEG || s.Command()[0] == define.FFPROBE {
			ctx, cancel := context.WithCancel(context.Background())
			defer cancel()

			go func() {
				// The context is canceled when the client's connection closes or I/ O operation fails.
				<-s.Context().Done()
				cancel()
			}()

			studioHome, err := utils.GetStudioHomeDir()
			if err != nil {
				sio.Fatalf(s, "GetStudioHomeDir error: %s\n", err.Error())
			}
			// ffmpeg or ffprobe
			ffBin := filepath.Join(studioHome, "host-shared", "ffmpeg", "bin", s.Command()[0])
			env := define.DYLD_LIBRARY_PATH + "=" + filepath.Join(studioHome, "host-shared", "ffmpeg", "lib")

			myRunner := ffmpeg.Runner{
				File:    ffBin,           // ffmpeg/ffprobe is the target binary
				Args:    s.Command()[1:], // Pass the rest of the command to ffmpeg
				Envs:    []string{env},
				Session: s,
			}

			if err = myRunner.Run(ctx); err != nil {
				logrus.Errorf("Run cmd error: %s", err.Error())
			}

			logrus.Infof("Clean up the tmp files generated by %s", myRunner.File)
			if err = myRunner.CleanUp(ctx); err != nil {
				logrus.Errorf("Clean up error: %s", err.Error())
			}
		} else {
			next(s)
		}
	}
}

func Sanitizers(next ssh.Handler) ssh.Handler {
	return func(s ssh.Session) {
		logrus.Infof("Sanitizing string: %q", s.Command())
		str := s.Command()
		if len(str) == 0 {
			sio.Fatalf(s, "Empty command, Support commands: %q", define.Whitelist)
		}

		// Sanitizing the command with whitelist
		if define.IsWhitelisted(str[0]) {
			next(s)
		} else {
			sio.Fatalf(s, "Command %q not allowed, Support commands: %q\n", str[0], define.Whitelist)
		}
	}
}
