package handler

import (
	"context"
	"github.com/gliderlabs/ssh"
	"github.com/sirupsen/logrus"
	"os"
	"path/filepath"
	"sshd/pkg/define"
	"sshd/pkg/exec"
	"sshd/pkg/handler/internal/ffmpeg"
	os2 "sshd/pkg/os"
	"sshd/pkg/sio"
	"sshd/pkg/utils"
)

type Middleware func(next ssh.Handler) ssh.Handler

// WithMiddleware composes the provided Middleware and returns an ssh.Option.
// This is useful if you manually create an ssh.Server and want to set the
// Server.Handler.
//
// Notice that middlewares are composed from first to last, which means the last one is executed first.
func WithMiddleware(mw ...Middleware) ssh.Option {
	return func(s *ssh.Server) error {
		h := func(ssh.Session) {}
		for _, m := range mw {
			h = m(h)
		}
		s.Handler = h
		return nil
	}
}

func InstallFFMPEG(next ssh.Handler) ssh.Handler {
	return func(s ssh.Session) {
		if s.Command()[0] == define.InstallFFMPEG {
			sio.Println(s, "Try to install ffmpeg")
			ctx, cancel := context.WithCancel(context.Background())
			defer cancel()
			go func() {
				// The context is canceled when the client's connection closes or I/ O operation fails.
				<-s.Context().Done()
				cancel()
			}()

			stduioHome, err := utils.GetStudioHomeDir()
			if err != nil {
				sio.Fatalf(s, "GetStudioHomeDir error: %s\n", err.Error())
				return
			}

			sio.Printf(s, "GetStudioHomeDir: %q\n", stduioHome)

			// by default, we pick up the ffmpeg for ventura
			ffURL := define.FFReleaseURLForVentura
			ffSha256Sum := define.FFMSha256ForVentura
			// For latest macOS version, we pack up the most recent ffmpeg binaries
			if os2.IsSequoia() {
				ffURL = define.FFReleaseURLForSequoia
				ffSha256Sum = define.FFMSha256ForSequoia
			}

			installer := ffmpeg.Installer{
				PREFIX:    filepath.Join(stduioHome, "host-shared"),
				URL:       ffURL,
				Session:   s,
				Sha256Sum: ffSha256Sum,
			}

			// Download ffmpeg
			if err = installer.Download(ctx); err != nil {
				sio.Fatalf(s, "Download ffmpeg error: %s\n", err.Error())
				return
			}

			// Unpack ffmpeg
			if err = installer.Unpack(ctx); err != nil {
				sio.Fatalf(s, "Unpack ffmpeg error: %s\n", err.Error())
				return
			}

			// Setup ffmpeg
			if err = installer.Setup(ctx); err != nil {
				sio.Fatalf(s, "Setup ffmpeg error: %s\n", err.Error())
				return
			}

			// Run ffmpeg -version for test
			if err = installer.Test(ctx); err != nil {
				sio.Fatalf(s, "Test ffmpeg error: %s\n", err.Error())
				return
			}

			// Clean up the tmp files generated by installer
			defer func() {
				if err = installer.CleanUp(ctx); err != nil {
					sio.Fatalf(s, "Test ffmpeg error: %s\n", err.Error())
				}
			}()
		} else {
			next(s)
		}
	}
}

func RunFFMPEG(next ssh.Handler) ssh.Handler {
	return func(s ssh.Session) {
		if s.Command()[0] == define.FFMPEG || s.Command()[0] == define.FFPROBE {
			ctx, cancel := context.WithCancel(context.Background())
			defer cancel()

			go func() {
				// The context is canceled when the client's connection closes or I/ O operation fails.
				<-s.Context().Done()
				cancel()
			}()

			studioHome, err := utils.GetStudioHomeDir()
			if err != nil {
				sio.Fatalf(s, "GetStudioHomeDir error: %s\n", err.Error())
			}
			// ffmpeg or ffprobe
			ffBin := filepath.Join(studioHome, "host-shared", "ffmpeg", "bin", s.Command()[0])
			env := define.DYLD_LIBRARY_PATH + "=" + filepath.Join(studioHome, "host-shared", "ffmpeg", "lib")

			progArgs, err := exec.DoArgsSanitizers(s.Command()[1:])
			if err != nil {
				logrus.Errorf("DoArgsSanitizers error: %s", err.Error())
				return
			}

			myRunner := ffmpeg.Runner{
				File:    ffBin,    // ffmpeg/ffprobe is the target binary
				Args:    progArgs, // Pass the rest of the command to ffmpeg
				Envs:    []string{env},
				Session: s,
			}

			if err = os.Chmod(myRunner.File, 0755); err != nil {
				logrus.Errorf("Chmod error: %v", err.Error())
				return
			}

			if err = myRunner.Run(ctx); err != nil {
				logrus.Errorf("Run cmd error: %s", err.Error())
				return
			}

			// Clean up the tmp files generated by ffmpeg/ffprobe
			defer func() {
				logrus.Infof("Clean up the tmp files generated by %s", myRunner.File)
				if err = myRunner.CleanUp(ctx); err != nil {
					logrus.Errorf("Clean up error: %s", err.Error())
				}
			}()
		} else {
			next(s)
		}
	}
}

func Sanitizers(next ssh.Handler) ssh.Handler {
	return func(s ssh.Session) {
		logrus.Infof("Sanitizing string: %q", s.Command())
		str := s.Command()
		if len(str) == 0 {
			sio.Fatalf(s, "Empty command, Support commands: %q", define.Whitelist)
		}

		// Sanitizing the command with whitelist
		if define.IsWhitelisted(str[0]) {
			next(s)
		} else {
			sio.Fatalf(s, "Command %q not allowed, Support commands: %q\n", str[0], define.Whitelist)
		}
	}
}
